#!/usr/bin/env python
"""This script generate a list of healthier swaps for products
which are not included in nutritional guidelines standards."""

import difflib
import pandas as pd
import numpy as np

import nltk
from nltk.corpus import stopwords

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.utils import shuffle

count_vectorizer = CountVectorizer(stop_words="english")
tfidf_vectorizer=TfidfVectorizer()


def update_stopwords():

    """Method to return stopwords"""

    nltk.download("stopwords")
    stop_words = stopwords.words("english")
    stop_words.extend(["from", "subject", "re", "edu", "use"])

    return stop_words


def recom_ranked(original_df, recommended_dataframe, barcode):

    """ Method to rank and sort the recommended dataframe """

    # Cosine similarity
    df_ranked = cosine_calculation(recommended_dataframe, barcode)
    df_ranked["cos_total"] = (
        df_ranked["cos_product_name"] + df_ranked["cos_ingredients"]
    ).round(2)
    df_ranked_sorted = df_ranked.sort_values(
        ["cos_total"], ascending=[False]
    ).reset_index()
    
    # Difflib
    search = original_df[original_df["barcode"] == barcode]
    search_str = str(search["product_name_clean"].values.tolist())
    words = df_ranked["product_name_clean"].values.tolist()
    df_rules_list = difflib.get_close_matches(search_str, words, n=200, cutoff=0.0)
    sorter_index = dict(zip(df_rules_list, range(len(df_rules_list))))
    df_ranked_sorted["Rank"] = df_ranked_sorted["product_name_clean"].map(sorter_index)
    df_ranked_sorted.sort_values(
        ["cos_total", "Rank"], ascending=[False, True], inplace=True
    )
    df_ranked_sorted.drop_duplicates(subset="product_name", inplace=True)
    df_ranked_sorted.drop_duplicates(subset="barcode", inplace=True)

    return df_ranked_sorted


def eligible_swaps(barcode, df):

    """Method to get all eligible swaps generated by the model capped at 100.
	If less than 100, all eligible swaps are shown"""

    if barcode not in df.barcode.unique():
        raise Exception("Sorry, barcode does not exist.")

    if (df[df["barcode"] == barcode]["badge_new"] == 1).all():
        raise Exception("Item has a good choice badge. Great choice.")

    recom = recom_check(barcode, df)
    if recom.empty:
        raise Exception("Item does not have healthier alternatives.")

    if recom["barcode"].iloc[0] != barcode:
        df_swaps = recom_ranked(df, recom, barcode)
        df_swaps.drop(df_swaps[df_swaps["barcode"] == barcode].index, inplace=True)
        df_swaps.drop(df_swaps[df_swaps["product_name"] == barcode].index, inplace=True)
        df_swaps.sort_values(["cos_total"], ascending=False, inplace=True)
    else:
        raise Exception("Item does not have healthier alternatives.")

    if len(df_swaps) > 100:
        df_swaps = df_swaps[:100]

    if len(df_swaps) == 0:
        raise Exception("Item does not have any alternatives.")

    df_swaps_final = df_swaps
    
    return df_swaps_final


def long_list_swaps(barcode, df):

    """ Method that takes in eligible_swaps dataframe and returns 10 at a time capped at 30"""

    if barcode not in df.barcode.unique():
        raise Exception("Sorry, barcode does not exist.")

    if (df[df["barcode"] == barcode]["badge_new"] == 1).all():
        raise Exception("Item has a good choice badge. Great choice.")

    recom = recom_check(barcode, df)
    if recom.empty:
        raise Exception("Item does not have healthier alternatives.")

    df_swaps = recom_ranked(df, recom, barcode)
    df_swaps.drop(df_swaps[df_swaps["barcode"] == barcode].index, inplace=True)

    if len(df_swaps) > 30:
        df_rand = shuffle(df_swaps[:30])

    if len(df_swaps) == 0:
        raise Exception("Item does not have any alternatives.")

    # df_rand = shuffle(df_swaps)
    df_swaps.sort_values(["cos_total"], ascending=False, inplace=True)

    return df_swaps


def top_3_swaps(barcode, df):

    """ Takes in eligible swaps and returns top 3 based on rules"""

    if barcode not in df.barcode.unique():
        raise Exception("Sorry, barcode does not exist.")

    if (df[df["barcode"] == barcode]["badge_new"] == 1).all():
        raise Exception("Item has a good choice badge. Great choice.")

    recom = recom_check(barcode, df)
    if recom.empty:
        raise Exception("Item does not have healthier alternatives.")

    df_swaps = recom_ranked(df, recom, barcode)
    df_swaps.sort_values(["cos_total"], ascending=False, inplace=True)

    if len(df_swaps) == 0:
        raise Exception("Item does not have any alternatives.")

    manufact = df[df["barcode"] == barcode]["manufacturer_clean"]
    retailer = df[df["barcode"] == barcode]["retailer_extract"]
    pgc = df_swaps[df_swaps["pgc_badge"] == 1][:1]
    df_swaps.drop(df_swaps[df_swaps["barcode"] == barcode].index, inplace=True)

    retailer = retailer.tolist()
    manufact = manufact.tolist()

    if len(pgc) == 0:
        if len(manufact) > 0:
            manu_swap = df_swaps[df_swaps["manufacturer_clean"] == manufact[0]][:1]

        if str(retailer) is None:
            retail_swaps = df_swaps
        else:
            retail_swaps = df_swaps[df_swaps["retailer_extract"].isin(retailer)]

        if len(manufact) > 0:
            if len(retail_swaps) > 2:
                retail_swaps = shuffle(retail_swaps[:2])
        else:
            retail_swaps = shuffle(retail_swaps[:3])

    else:
        if len(manufact) > 0:
            manu_swap = df_swaps[df_swaps["manufacturer_clean"] == manufact[0]][:1]

        if str(retailer) is None:
            retail_swaps = df_swaps
        else:
            retail_swaps = df_swaps[df_swaps["retailer_extract"].isin(retailer)]

        if len(manufact) > 0:
            if len(retail_swaps) > 2:
                retail_swaps = shuffle(retail_swaps[:1])
        else:
            retail_swaps = shuffle(retail_swaps[:2])

    new_df = retail_swaps.append(manu_swap)
    new_df_pgc = new_df.append(pgc)
    new_df_pgc.drop_duplicates(subset="product_name", inplace=True)

    if len(new_df_pgc) == 0:
        raise Exception("Item does not have any alternatives.")

    tries = 0
    while len(new_df_pgc) < 3:
        new_df_pgc = new_df_pgc.append(df_swaps[:100].sample())
        new_df_pgc.drop_duplicates(subset="product_name", inplace=True)
        tries += 1
        if tries >= 15:
            raise Exception(
                "Sorry, this product does not have enough swaps to build a top 3."
            )

    new_df_pgc.sort_values(["cos_total"], ascending=False, inplace=True)

    return new_df_pgc


def top_100_swaps(barcode, df):

    """Method to get all eligible swaps generated by the model, ordered by RANK, 
    capped at 100 including top 3 swaps.
    If less than 100, all eligible swaps are shown"""
    

    if barcode not in df.barcode.unique():
        raise Exception("Sorry, barcode does not exist.")

    if (df[df["barcode"] == barcode]["badge_new"] == 1).all():
        raise Exception("Item has a good choice badge. Great choice.")
    
    recom = recom_check(barcode, df)
    
    if recom.empty:
        raise Exception("Item does not have healthier alternatives.")
    
    if recom["barcode"].iloc[0] != barcode:
        df_swaps = recom_ranked(df, recom, barcode)
        df_swaps.drop(df_swaps[df_swaps["barcode"] == barcode].index, inplace=True)
        df_swaps = df_swaps[df_swaps['cos_product_name'] > 0.052]
        df_swaps = df_swaps[df_swaps['cos_total'] > 0.10]
        df_swaps.sort_values(["Rank"], ascending=True, inplace=True)
    else:
        raise Exception("Item does not have healthier alternatives.")

    if len(df_swaps) == 0:
        raise Exception("Item does not have any alternatives.")

    df_swaps.drop(df_swaps[df_swaps["barcode"] == barcode].index, inplace=True)
    
    # Dropping same products (disregarding of size)
    df_swaps.drop_duplicates(subset = "product_clean", keep = 'first', inplace = True)
    
    df_swaps = df_swaps[:100]

    manufact = df[df["barcode"] == barcode]["manufacturer_clean"]
    retailer = df[df["barcode"] == barcode]["retailer_extract"]
    pgc = df_swaps[df_swaps["pgc_badge"] == 1][:1]

    retailer = retailer.tolist()
    manufact = manufact.tolist()

    if len(pgc) == 0:
        if len(manufact) > 0:
            manu_swap = df_swaps[df_swaps["manufacturer_clean"] == manufact[0]][:1]

        if str(retailer) is None:
            retail_swaps = df_swaps
        else:
            retail_swaps = df_swaps[df_swaps["retailer_extract"].isin(retailer)][:1]

        if len(manufact) > 0:
            if len(retail_swaps) > 2:
                retail_swaps = shuffle(retail_swaps[:2])
        else:
            retail_swaps = shuffle(retail_swaps[:3])

    else:
        if len(manufact) > 0:
            manu_swap = df_swaps[df_swaps["manufacturer_clean"] == manufact[0]][:1]

        if str(retailer) is None:
            retail_swaps = df_swaps
        else:
            retail_swaps = df_swaps[df_swaps["retailer_extract"].isin(retailer)][:1]

        if len(manufact) > 0:
            if len(retail_swaps) > 2:
                retail_swaps = shuffle(retail_swaps[:1])
        else:
            retail_swaps = shuffle(retail_swaps[:2])

    new_df = retail_swaps.append(manu_swap)
    new_df_pgc = new_df.append(pgc)
    new_df_pgc.drop_duplicates(subset="product_name", inplace=True)
    
    if len(new_df_pgc) == 0:
        raise Exception("Item does not have any alternatives.")
    
    if len(df_swaps) > 3:

        tries = 0
        idx = 0

        while len(new_df_pgc) < 3:
            new_df_pgc = new_df_pgc.append(df_swaps.iloc[idx])
            new_df_pgc.drop_duplicates(subset="product_name", inplace=True)
            tries += 1
            idx +=1
            if tries >= 15:
                break


    new_df_pgc.sort_values(["Rank"], ascending=True, inplace=True)

    full_100 = pd.concat([new_df_pgc, df_swaps])
    full_100.drop_duplicates(subset="product_name", inplace=True)

    return full_100


def selection(barcode, df):

    """Function to filter DataFrame for manufacturer, PHE_cat and product
	according to the scanned barcode. The function also defines ranges for
	packsize and packcount based on the desired user-defined size percent
	and count percent."""

    size_percent = 0.2
    count_percent = 0.2

    # Pull out manufacturer
    manufacturer = df.loc[df["barcode"] == barcode, "manufacturer_clean"]
    PHE_cat = df.loc[df["barcode"] == barcode, "PHE_cat"].iloc[0]
    category = df.loc[df["barcode"] == barcode, "category"].iloc[0]

    # Get rid of null values
    df["packsize"].fillna(0, inplace=True)
    df["packcount"].fillna(0, inplace=True)

    # RegEx for getting the clean name of the product (without it size)
    df['product_clean'] = df['product_name'].str.extract("([a-zA-Z äü&'-,]+)", expand=False).str.strip()
    
    # Convert Product Clean column to lowercase for further removing duplicates
    df['product_clean'] = df['product_clean'].str.lower()

    # define range for packsize
    packsize = float(df.loc[df["barcode"] == barcode, "packsize"].iloc[0])
    packsize_low = float(packsize - packsize * size_percent)
    packsize_high = float(packsize + packsize * size_percent)

    # define range for packcount
    packcount = int(df.loc[df["barcode"] == barcode, "packcount"].iloc[0])
    packcount_low = int(packcount - packcount * count_percent)
    packcount_high = int(packcount + packcount * count_percent)
    
    # checking if the item has packsize
    """
    if packsize == 0 and PHE_cat is not np.nan:

        df_manuf = df[
            df.manufacturer_clean.isin(manufacturer)
            & (df.PHE_cat == PHE_cat)
            & (packcount_low <= df.packcount.astype(int))
            & (df.packcount.astype(int) <= packcount_high)
        ]

        df_PHE_cat = df[
            (df.PHE_cat == PHE_cat)
            & (df.barcode != barcode)
            & ~(df.manufacturer_clean.isin(manufacturer))
            & (packcount_low <= df.packcount.astype(int))
            & (df.packcount.astype(int) <= packcount_high)
        ]
    """

    if PHE_cat is not np.nan:

        df_manuf = df[
            (df.manufacturer_clean.isin(manufacturer))
            & (df.PHE_cat == PHE_cat)
            #& (packsize_low <= df.packsize.astype(int))
            #& (df.packsize.astype(int) <= packsize_high)
            #& (packcount_low <= df.packcount.astype(int))
            #& (df.packcount.astype(int) <= packcount_high)
        ]

        df_PHE_cat = df[
            (df.PHE_cat == PHE_cat)
            & (df.barcode != barcode)
            & ~(df.manufacturer_clean.isin(manufacturer))
            #& (packsize_low <= df.packsize.astype(int))
            #& (df.packsize.astype(int) <= packsize_high)
            #& (packcount_low <= df.packcount.astype(int))
            #& (df.packcount.astype(int) <= packcount_high)
        ]

    if PHE_cat is np.nan:

        raise Exception("Product category is None so no swaps are available for this item.")

    df_selected = df_manuf.append(df_PHE_cat)
    
    return df_selected


def recom_check(barcode, df):

    """Method to check the number of recommended items which have badges, high five man or both.
	n_recommendation is the desired minimum number of recommendation"""
    
    df_check = selection(barcode, df)
    
    n_recommendation = 3
    size_percent = 0.2
    count_percent = 0.2

    # Keep item row in variable
    item = df_check[df_check["barcode"] == barcode]

    # Filter for badge new
    df_check_badge = df_check[df_check["badge_new"] == 1]

    # filter for high five man
    df_check_hfm = df_check[df_check["high_five_man"] == 1]

    # concatenate high five man and badge new datafarmes
    df_check_final = pd.concat([df_check_badge, df_check_hfm], ignore_index=True)

    # Remove any duplicates
    df_check_final = df_check_final.drop_duplicates(["barcode"], keep="first")

    # Add barcode item if it has been filtered out
    if barcode not in df_check_final.barcode.values:
        df_check_final = pd.concat([df_check_final, item], ignore_index=True)
    
    """
    if len(df_check_final) < n_recommendation:

        # run through the selection check again but with subcategories added
        # to get more eligible swaps
        manufacturer = df.loc[df["barcode"] == barcode, "manufacturer_clean"]
        PHE_cat = df.loc[df["barcode"] == barcode, "main_and_sub1"].iloc[0]

        # define range for packsize
        packsize = float(df.loc[df["barcode"] == barcode, "packsize"].iloc[0])
        packsize_low = float(packsize - packsize * size_percent)
        packsize_high = float(packsize + packsize * size_percent)

        # define range for packcount
        packcount = int(df.loc[df["barcode"] == barcode, "packcount"].iloc[0])
        packcount_low = int(packcount - packcount * count_percent)
        packcount_high = int(packcount + packcount * count_percent)

        # To check if the item has packsize
        if packsize == 0:
            # raise Exception('Packsize of product is 0.')
            df_manuf = df[
                df.manufacturer_clean.isin(manufacturer)
                & (df["main_and_sub1"] == PHE_cat)
                & (packcount_low <= df.packcount.astype(int))
                & (df.packcount.astype(int) <= packcount_high)
            ]
            
            df_PHE_cat = df[
                (df["main_and_sub1"] == PHE_cat)
                & (df.barcode != barcode)
                & ~(df.manufacturer_clean.isin(manufacturer))
                & (packcount_low <= df.packcount.astype(int))
                & (df.packcount.astype(int) <= packcount_high)
            ]
        else:
            df_manuf = df[
                (df.manufacturer_clean.isin(manufacturer))
                & (df["main_and_sub1"] == PHE_cat)
                & (packsize_low <= df.packsize.astype(int))
                & (df.packsize.astype(int) <= packsize_high)
                & (packcount_low <= df.packcount.astype(int))
                & (df.packcount.astype(int) <= packcount_high)
            ]

            df_PHE_cat = df[
                (df["main_and_sub1"] == PHE_cat)
                & (df.barcode != barcode)
                & (packsize_low <= df.packsize.astype(int))
                & (df.packsize.astype(int) <= packsize_high)
                & (packcount_low <= df.packcount.astype(int))
                & (df.packcount.astype(int) <= packcount_high)
            ]
        
        df_selected = df_manuf.append(df_PHE_cat)
        df_check_badge = df_selected[df_selected["badge_new"] == 1]
        df_check_hfm = df_selected[df_selected["high_five_man"] == 1]
        df_check_final = pd.concat([df_check_badge, df_check_hfm], ignore_index=True)
        df_check_final = df_check_final.drop_duplicates(["barcode"], keep="first")

        # Add barcode item if it has been filtered out
        if barcode not in df_check_final.barcode.values:
            df_check_final = pd.concat([df_check_final, item], ignore_index=True)

        # filter for desired columns
        df_check_final = df_check_final[
            [
                "barcode",
                "product_name",
                "product_name_clean",
                "ingredients",
                "ingredients_clean",
                "badge_new",
                "packsize",
                "packcount",
                "sugar_100",
                "fat_100",
                "salt_100",
                "main_category_name",
                "sub_category_name",
                "product_category_name",
                "high_five_man",
                "packsize_extract",
                "PHE_cat",
                "manufacturer_clean",
                "retailer_extract",
                "pgc_badge",
            ]
        ]
    """

    df_selected = selection(barcode, df)
    df_check_badge = df_selected[df_selected["badge_new"] == 1]
    df_check_hfm = df_selected[df_selected["high_five_man"] == 1]
    df_check_final = pd.concat([df_check_badge, df_check_hfm], ignore_index=True)
    df_check_final = df_check_final.drop_duplicates(["barcode"], keep="first")

    # Add barcode item if it has been filtered out
    if barcode not in df_check_final.barcode.values:
        df_check_final = pd.concat([df_check_final, item], ignore_index=True)

    # Filter for desired columns
    df_check_final = df_check_final[
        [
            "barcode",
            "product_name",
            "product_name_clean",
            "ingredients",
            "ingredients_clean",
            "badge_new",
            "packsize",
            "packcount",
            "sugar_100",
            "fat_100",
            "salt_100",
            "main_category_name",
            "sub_category_name",
            "product_category_name",
            "high_five_man",
            "packsize_extract",
            "PHE_cat",
            "manufacturer_clean",
            "retailer_extract",
            "pgc_badge",
            "product_clean"
        ]
    ]
    
    # Fill the ingredients_clean NaNs with product_name_clean from corresponding row
    df_check_final["ingredients"].fillna(
        df_check_final["product_name"], inplace=True
    )

    # Filter by same retailer and None values
    retailer = df[df["barcode"] == barcode]["retailer_extract"]
    # retailer = retailer.to_list()

    if pd.isnull(retailer).iloc[0] == False:
        df_check_final = df_check_final[
            (df_check_final["retailer_extract"].isin([retailer.iloc[0]]))
            | (df_check_final["retailer_extract"].isna())
        ]
    else:
        pass
    
    return df_check_final


def cosine_calculation(df, barcode):

    """Method to calculate the cosine similarities between items. The cosine similarities will
	be used to rank the recommended items"""

    columns_list = ["product_name", "ingredients"]
    # item = df[df["barcode"] == barcode]
    # if barcode not in df.barcode.values:
    #         df = pd.concat([df, item], ignore_index=True)
    product_scanned = df[df['barcode'] == barcode]

    for i in columns_list:
        
        df_list = np.array(df[i])
        sparse_matrix = tfidf_vectorizer.fit_transform([product_scanned[i].iloc[0]] + df_list)
        doc_term_matrix = sparse_matrix.todense()
        df_model = pd.DataFrame(
            doc_term_matrix,
            columns=tfidf_vectorizer.get_feature_names(),
            index=[df_list],
        )

        cosine = pd.DataFrame(cosine_similarity(df_model))

        df.reset_index(drop=True, inplace=True)
        cosine.reset_index(drop=True, inplace=True)

        df = df.join(cosine[0])

        name = "cos_" + str(i)
        df = df.rename(columns={0: name})

    return df
